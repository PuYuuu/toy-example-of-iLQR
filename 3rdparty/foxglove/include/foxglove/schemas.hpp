// Generated by https://github.com/foxglove/foxglove-sdk

#pragma once

#include <foxglove/context.hpp>
#include <foxglove/error.hpp>
#include <foxglove/time.hpp>

#include <array>
#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <vector>

struct foxglove_channel;

namespace foxglove::schemas {

/// @brief A functor for freeing a channel. Used by ChannelUniquePtr. For internal use only.
struct ChannelDeleter {
  /// @brief free the channel
  void operator()(const foxglove_channel* ptr) const noexcept;
};
/// @brief A unique pointer to a C foxglove_channel pointer. For internal use only.
typedef std::unique_ptr<const foxglove_channel, ChannelDeleter> ChannelUniquePtr;

/// @brief A vector in 3D space that represents a direction only
struct Vector3 {
  /// @brief x coordinate length
  double x = 0;

  /// @brief y coordinate length
  double y = 0;

  /// @brief z coordinate length
  double z = 0;
};

/// @brief A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
struct Quaternion {
  /// @brief x value
  double x = 0;

  /// @brief y value
  double y = 0;

  /// @brief z value
  double z = 0;

  /// @brief w value
  double w = 0;
};

/// @brief A position and orientation for an object or reference frame in 3D space
struct Pose {
  /// @brief Point denoting position in 3D space
  std::optional<Vector3> position;

  /// @brief Quaternion denoting orientation in 3D space
  std::optional<Quaternion> orientation;
};

/// @brief A color in RGBA format
struct Color {
  /// @brief Red value between 0 and 1
  double r = 0;

  /// @brief Green value between 0 and 1
  double g = 0;

  /// @brief Blue value between 0 and 1
  double b = 0;

  /// @brief Alpha value between 0 and 1
  double a = 0;
};

/// @brief A primitive representing an arrow
struct ArrowPrimitive {
  /// @brief Position of the arrow's tail and orientation of the arrow. Identity orientation means
  /// the arrow points in the +x direction.
  std::optional<Pose> pose;

  /// @brief Length of the arrow shaft
  double shaft_length = 0;

  /// @brief Diameter of the arrow shaft
  double shaft_diameter = 0;

  /// @brief Length of the arrow head
  double head_length = 0;

  /// @brief Diameter of the arrow head
  double head_diameter = 0;

  /// @brief Color of the arrow
  std::optional<Color> color;
};

/// @brief Camera calibration parameters
struct CameraCalibration {
  /// @brief Timestamp of calibration data
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference for the camera. The origin of the frame is the optical center of the
  /// camera. +x points to the right in the image, +y points down, and +z points into the plane of
  /// the image.
  std::string frame_id;

  /// @brief Image width
  uint32_t width = 0;

  /// @brief Image height
  uint32_t height = 0;

  /// @brief Name of distortion model
  /// @brief
  /// @brief Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3), `rational_polynomial` (k1, k2,
  /// p1, p2, k3, k4, k5, k6), and `kannala_brandt` (k1, k2, k3, k4). `plumb_bob` and
  /// `rational_polynomial` models are based on the pinhole model
  /// [OpenCV's](https://docs.opencv.org/4.11.0/d9/d0c/group__calib3d.html) [pinhole camera
  /// model](https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction). The
  /// `kannala_brandt` model is matches the [OpenvCV
  /// fisheye](https://docs.opencv.org/4.11.0/db/d58/group__calib3d__fisheye.html) model.
  std::string distortion_model;

  /// @brief Distortion parameters
  std::vector<double> d;

  /// @brief Intrinsic camera matrix (3x3 row-major matrix)
  /// @brief
  /// @brief A 3x3 row-major matrix for the raw (distorted) image.
  /// @brief
  /// @brief Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the
  /// focal lengths (fx, fy) and principal point (cx, cy).
  /// @brief
  /// @brief ```
  /// @brief     [fx  0 cx]
  /// @brief K = [ 0 fy cy]
  /// @brief     [ 0  0  1]
  /// @brief ```
  /// @brief
  std::array<double, 9> k;

  /// @brief Rectification matrix (stereo cameras only, 3x3 row-major matrix)
  /// @brief
  /// @brief A rotation matrix aligning the camera coordinate system to the ideal stereo image plane
  /// so that epipolar lines in both stereo images are parallel.
  std::array<double, 9> r;

  /// @brief Projection/camera matrix (3x4 row-major matrix)
  /// @brief
  /// @brief ```
  /// @brief     [fx'  0  cx' Tx]
  /// @brief P = [ 0  fy' cy' Ty]
  /// @brief     [ 0   0   1   0]
  /// @brief ```
  /// @brief
  /// @brief By convention, this matrix specifies the intrinsic (camera) matrix of the processed
  /// (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the
  /// rectified image.
  /// @brief
  /// @brief It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the
  /// focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in
  /// K.
  /// @brief
  /// @brief For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the
  /// identity and P[1:3,1:3] = K.
  /// @brief
  /// @brief For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the
  /// optical center of the second camera in the first camera's frame. We assume Tz = 0 so both
  /// cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the
  /// right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the
  /// baseline between the cameras.
  /// @brief
  /// @brief Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image
  /// is given by:
  /// @brief
  /// @brief ```
  /// @brief [u v w]' = P * [X Y Z 1]'
  /// @brief        x = u / w
  /// @brief        y = v / w
  /// @brief ```
  /// @brief
  /// @brief This holds for both images of a stereo pair.
  /// @brief
  std::array<double, 12> p;
};

/// @brief A point representing a position in 2D space
struct Point2 {
  /// @brief x coordinate position
  double x = 0;

  /// @brief y coordinate position
  double y = 0;
};

/// @brief A circle annotation on a 2D image
struct CircleAnnotation {
  /// @brief Timestamp of circle
  std::optional<Timestamp> timestamp;

  /// @brief Center of the circle in 2D image coordinates (pixels).
  /// @brief The coordinate uses the top-left corner of the top-left pixel of the image as the
  /// origin.
  std::optional<Point2> position;

  /// @brief Circle diameter in pixels
  double diameter = 0;

  /// @brief Line thickness in pixels
  double thickness = 0;

  /// @brief Fill color
  std::optional<Color> fill_color;

  /// @brief Outline color
  std::optional<Color> outline_color;
};

/// @brief A compressed image
struct CompressedImage {
  /// @brief Timestamp of image
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference for the image. The origin of the frame is the optical center of the
  /// camera. +x points to the right in the image, +y points down, and +z points into the plane of
  /// the image.
  std::string frame_id;

  /// @brief Compressed image data
  std::vector<std::byte> data;

  /// @brief Image format
  /// @brief
  /// @brief Supported values: `jpeg`, `png`, `webp`, `avif`
  std::string format;
};

/// @brief A single frame of a compressed video bitstream
struct CompressedVideo {
  /// @brief Timestamp of video frame
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference for the video.
  /// @brief
  /// @brief The origin of the frame is the optical center of the camera. +x points to the right in
  /// the video, +y points down, and +z points into the plane of the video.
  std::string frame_id;

  /// @brief Compressed video frame data.
  /// @brief
  /// @brief For packet-based video codecs this data must begin and end on packet boundaries (no
  /// partial packets), and must contain enough video packets to decode exactly one image (either a
  /// keyframe or delta frame). Note: Foxglove does not support video streams that include B frames
  /// because they require lookahead.
  /// @brief
  /// @brief Specifically, the requirements for different `format` values are:
  /// @brief
  /// @brief - `h264`
  /// @brief   - Use Annex B formatted data
  /// @brief   - Each CompressedVideo message should contain enough NAL units to decode exactly one
  /// video frame
  /// @brief   - Each message containing a key frame (IDR) must also include a SPS NAL unit
  /// @brief
  /// @brief - `h265` (HEVC)
  /// @brief   - Use Annex B formatted data
  /// @brief   - Each CompressedVideo message should contain enough NAL units to decode exactly one
  /// video frame
  /// @brief   - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS
  /// NAL units
  /// @brief
  /// @brief - `vp9`
  /// @brief   - Each CompressedVideo message should contain exactly one video frame
  /// @brief
  /// @brief - `av1`
  /// @brief   - Use the "Low overhead bitstream format" (section 5.2)
  /// @brief   - Each CompressedVideo message should contain enough OBUs to decode exactly one video
  /// frame
  /// @brief   - Each message containing a key frame must also include a Sequence Header OBU
  std::vector<std::byte> data;

  /// @brief Video format.
  /// @brief
  /// @brief Supported values: `h264`, `h265`, `vp9`, `av1`.
  /// @brief
  /// @brief Note: compressed video support is subject to hardware limitations and patent licensing,
  /// so not all encodings may be supported on all platforms. See more about [H.265
  /// support](https://caniuse.com/hevc), [VP9 support](https://caniuse.com/webm), and [AV1
  /// support](https://caniuse.com/av1).
  std::string format;
};

/// @brief A primitive representing a cylinder, elliptic cylinder, or truncated cone
struct CylinderPrimitive {
  /// @brief Position of the center of the cylinder and orientation of the cylinder. The flat
  /// face(s) are perpendicular to the z-axis.
  std::optional<Pose> pose;

  /// @brief Size of the cylinder's bounding box
  std::optional<Vector3> size;

  /// @brief 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the
  /// bounding box
  double bottom_scale = 0;

  /// @brief 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the
  /// bounding box
  double top_scale = 0;

  /// @brief Color of the cylinder
  std::optional<Color> color;
};

/// @brief A primitive representing a cube or rectangular prism
struct CubePrimitive {
  /// @brief Position of the center of the cube and orientation of the cube
  std::optional<Pose> pose;

  /// @brief Size of the cube along each axis
  std::optional<Vector3> size;

  /// @brief Color of the cube
  std::optional<Color> color;
};

/// @brief A transform between two reference frames in 3D space
struct FrameTransform {
  /// @brief Timestamp of transform
  std::optional<Timestamp> timestamp;

  /// @brief Name of the parent frame
  std::string parent_frame_id;

  /// @brief Name of the child frame
  std::string child_frame_id;

  /// @brief Translation component of the transform
  std::optional<Vector3> translation;

  /// @brief Rotation component of the transform
  std::optional<Quaternion> rotation;
};

/// @brief An array of FrameTransform messages
struct FrameTransforms {
  /// @brief Array of transforms
  std::vector<FrameTransform> transforms;
};

/// @brief GeoJSON data for annotating maps
struct GeoJSON {
  /// @brief GeoJSON data encoded as a UTF-8 string
  std::string geojson;
};

/// @brief A vector in 2D space that represents a direction only
struct Vector2 {
  /// @brief x coordinate length
  double x = 0;

  /// @brief y coordinate length
  double y = 0;
};

/// @brief A field present within each element in a byte array of packed elements.
struct PackedElementField {
  /// @brief Numeric type
  enum class NumericType : uint8_t {
    /// @brief Unknown numeric type
    UNKNOWN = 0,
    /// @brief Unsigned 8-bit integer
    UINT8 = 1,
    /// @brief Signed 8-bit integer
    INT8 = 2,
    /// @brief Unsigned 16-bit integer
    UINT16 = 3,
    /// @brief Signed 16-bit integer
    INT16 = 4,
    /// @brief Unsigned 32-bit integer
    UINT32 = 5,
    /// @brief Signed 32-bit integer
    INT32 = 6,
    /// @brief 32-bit floating-point number
    FLOAT32 = 7,
    /// @brief 64-bit floating-point number
    FLOAT64 = 8,
  };
  /// @brief Name of the field
  std::string name;

  /// @brief Byte offset from start of data buffer
  uint32_t offset = 0;

  /// @brief Type of data in the field. Integers are stored using little-endian byte order.
  NumericType type;
};

/// @brief A 2D grid of data
struct Grid {
  /// @brief Timestamp of grid
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference
  std::string frame_id;

  /// @brief Origin of grid's corner relative to frame of reference; grid is positioned in the x-y
  /// plane relative to this origin
  std::optional<Pose> pose;

  /// @brief Number of grid columns
  uint32_t column_count = 0;

  /// @brief Size of single grid cell along x and y axes, relative to `pose`
  std::optional<Vector2> cell_size;

  /// @brief Number of bytes between rows in `data`
  uint32_t row_stride = 0;

  /// @brief Number of bytes between cells within a row in `data`
  uint32_t cell_stride = 0;

  /// @brief Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the
  /// grid's color.
  std::vector<PackedElementField> fields;

  /// @brief Grid cell data, interpreted using `fields`, in row-major (y-major) order â€” values fill
  /// each row from left to right along the X axis, with rows ordered from top to bottom along the Y
  /// axis, starting at the bottom-left corner when viewed from +Z looking towards -Z with identity
  /// orientations
  std::vector<std::byte> data;
};

/// @brief An array of points on a 2D image
struct PointsAnnotation {
  /// @brief Type of points annotation
  enum class PointsAnnotationType : uint8_t {
    /// @brief Unknown points annotation type
    UNKNOWN = 0,
    /// @brief Individual points: 0, 1, 2, ...
    POINTS = 1,
    /// @brief Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
    LINE_LOOP = 2,
    /// @brief Connected line segments: 0-1, 1-2, ..., (n-1)-n
    LINE_STRIP = 3,
    /// @brief Individual line segments: 0-1, 2-3, 4-5, ...
    LINE_LIST = 4,
  };
  /// @brief Timestamp of annotation
  std::optional<Timestamp> timestamp;

  /// @brief Type of points annotation to draw
  PointsAnnotationType type;

  /// @brief Points in 2D image coordinates (pixels).
  /// @brief These coordinates use the top-left corner of the top-left pixel of the image as the
  /// origin.
  std::vector<Point2> points;

  /// @brief Outline color
  std::optional<Color> outline_color;

  /// @brief Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is
  /// `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
  std::vector<Color> outline_colors;

  /// @brief Fill color
  std::optional<Color> fill_color;

  /// @brief Stroke thickness in pixels
  double thickness = 0;
};

/// @brief A text label on a 2D image
struct TextAnnotation {
  /// @brief Timestamp of annotation
  std::optional<Timestamp> timestamp;

  /// @brief Bottom-left origin of the text label in 2D image coordinates (pixels).
  /// @brief The coordinate uses the top-left corner of the top-left pixel of the image as the
  /// origin.
  std::optional<Point2> position;

  /// @brief Text to display
  std::string text;

  /// @brief Font size in pixels
  double font_size = 0;

  /// @brief Text color
  std::optional<Color> text_color;

  /// @brief Background fill color
  std::optional<Color> background_color;
};

/// @brief Array of annotations for a 2D image
struct ImageAnnotations {
  /// @brief Circle annotations
  std::vector<CircleAnnotation> circles;

  /// @brief Points annotations
  std::vector<PointsAnnotation> points;

  /// @brief Text annotations
  std::vector<TextAnnotation> texts;
};

/// @brief A key with its associated value
struct KeyValuePair {
  /// @brief Key
  std::string key;

  /// @brief Value
  std::string value;
};

/// @brief A single scan from a planar laser range-finder
struct LaserScan {
  /// @brief Timestamp of scan
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference
  std::string frame_id;

  /// @brief Origin of scan relative to frame of reference; points are positioned in the x-y plane
  /// relative to this origin; angles are interpreted as counterclockwise rotations around the z
  /// axis with 0 rad being in the +x direction
  std::optional<Pose> pose;

  /// @brief Bearing of first point, in radians
  double start_angle = 0;

  /// @brief Bearing of last point, in radians
  double end_angle = 0;

  /// @brief Distance of detections from origin; assumed to be at equally-spaced angles between
  /// `start_angle` and `end_angle`
  std::vector<double> ranges;

  /// @brief Intensity of detections
  std::vector<double> intensities;
};

/// @brief A point representing a position in 3D space
struct Point3 {
  /// @brief x coordinate position
  double x = 0;

  /// @brief y coordinate position
  double y = 0;

  /// @brief z coordinate position
  double z = 0;
};

/// @brief A primitive representing a series of points connected by lines
struct LinePrimitive {
  /// @brief An enumeration indicating how input points should be interpreted to create lines
  enum class LineType : uint8_t {
    /// @brief Connected line segments: 0-1, 1-2, ..., (n-1)-n
    LINE_STRIP = 0,
    /// @brief Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
    LINE_LOOP = 1,
    /// @brief Individual line segments: 0-1, 2-3, 4-5, ...
    LINE_LIST = 2,
  };
  /// @brief Drawing primitive to use for lines
  LineType type;

  /// @brief Origin of lines relative to reference frame
  std::optional<Pose> pose;

  /// @brief Line thickness
  double thickness = 0;

  /// @brief Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in
  /// world coordinates and scales with distance from the camera (false)
  bool scale_invariant = false;

  /// @brief Points along the line
  std::vector<Point3> points;

  /// @brief Solid color to use for the whole line. One of `color` or `colors` must be provided.
  std::optional<Color> color;

  /// @brief Per-point colors (if specified, must have the same length as `points`). One of `color`
  /// or `colors` must be provided.
  std::vector<Color> colors;

  /// @brief Indices into the `points` and `colors` attribute arrays, which can be used to avoid
  /// duplicating attribute data.
  /// @brief
  /// @brief If omitted or empty, indexing will not be used. This default behavior is equivalent to
  /// specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
  std::vector<uint32_t> indices;
};

/// @brief A navigation satellite fix for any Global Navigation Satellite System
struct LocationFix {
  /// @brief Type of position covariance
  enum class PositionCovarianceType : uint8_t {
    /// @brief Unknown position covariance type
    UNKNOWN = 0,
    /// @brief Position covariance is approximated
    APPROXIMATED = 1,
    /// @brief Position covariance is per-axis, so put it along the diagonal
    DIAGONAL_KNOWN = 2,
    /// @brief Position covariance of the fix is known
    KNOWN = 3,
  };
  /// @brief Timestamp of the message
  std::optional<Timestamp> timestamp;

  /// @brief Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
  std::string frame_id;

  /// @brief Latitude in degrees
  double latitude = 0;

  /// @brief Longitude in degrees
  double longitude = 0;

  /// @brief Altitude in meters
  double altitude = 0;

  /// @brief Position covariance (m^2) defined relative to a tangential plane through the reported
  /// position. The components are East, North, and Up (ENU), in row-major order.
  std::array<double, 9> position_covariance;

  /// @brief If `position_covariance` is available, `position_covariance_type` must be set to
  /// indicate the type of covariance.
  PositionCovarianceType position_covariance_type;
};

/// @brief A log message
struct Log {
  /// @brief Log level
  enum class LogLevel : uint8_t {
    /// @brief Unknown log level
    UNKNOWN = 0,
    /// @brief Debug log level
    DEBUG = 1,
    /// @brief Info log level
    INFO = 2,
    /// @brief Warning log level
    WARNING = 3,
    /// @brief Error log level
    ERROR = 4,
    /// @brief Fatal log level
    FATAL = 5,
  };
  /// @brief Timestamp of log message
  std::optional<Timestamp> timestamp;

  /// @brief Log level
  LogLevel level;

  /// @brief Log message
  std::string message;

  /// @brief Process or node name
  std::string name;

  /// @brief Filename
  std::string file;

  /// @brief Line number in the file
  uint32_t line = 0;
};

/// @brief Command to remove previously published entities
struct SceneEntityDeletion {
  /// @brief An enumeration indicating which entities should match a SceneEntityDeletion command
  enum class SceneEntityDeletionType : uint8_t {
    /// @brief Delete the existing entity on the same topic that has the provided `id`
    MATCHING_ID = 0,
    /// @brief Delete all existing entities on the same topic
    ALL = 1,
  };
  /// @brief Timestamp of the deletion. Only matching entities earlier than this timestamp will be
  /// deleted.
  std::optional<Timestamp> timestamp;

  /// @brief Type of deletion action to perform
  SceneEntityDeletionType type;

  /// @brief Identifier which must match if `type` is `MATCHING_ID`.
  std::string id;
};

/// @brief A primitive representing a sphere or ellipsoid
struct SpherePrimitive {
  /// @brief Position of the center of the sphere and orientation of the sphere
  std::optional<Pose> pose;

  /// @brief Size (diameter) of the sphere along each axis
  std::optional<Vector3> size;

  /// @brief Color of the sphere
  std::optional<Color> color;
};

/// @brief A primitive representing a set of triangles or a surface tiled by triangles
struct TriangleListPrimitive {
  /// @brief Origin of triangles relative to reference frame
  std::optional<Pose> pose;

  /// @brief Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
  std::vector<Point3> points;

  /// @brief Solid color to use for the whole shape. One of `color` or `colors` must be provided.
  std::optional<Color> color;

  /// @brief Per-vertex colors (if specified, must have the same length as `points`). One of `color`
  /// or `colors` must be provided.
  std::vector<Color> colors;

  /// @brief Indices into the `points` and `colors` attribute arrays, which can be used to avoid
  /// duplicating attribute data.
  /// @brief
  /// @brief If omitted or empty, indexing will not be used. This default behavior is equivalent to
  /// specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
  std::vector<uint32_t> indices;
};

/// @brief A primitive representing a text label
struct TextPrimitive {
  /// @brief Position of the center of the text box and orientation of the text. Identity
  /// orientation means the text is oriented in the xy-plane and flows from -x to +x.
  std::optional<Pose> pose;

  /// @brief Whether the text should respect `pose.orientation` (false) or always face the camera
  /// (true)
  bool billboard = false;

  /// @brief Font size (height of one line of text)
  double font_size = 0;

  /// @brief Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in
  /// world coordinates and scales with distance from the camera (false)
  bool scale_invariant = false;

  /// @brief Color of the text
  std::optional<Color> color;

  /// @brief Text
  std::string text;
};

/// @brief A primitive representing a 3D model file loaded from an external URL or embedded data
struct ModelPrimitive {
  /// @brief Origin of model relative to reference frame
  std::optional<Pose> pose;

  /// @brief Scale factor to apply to the model along each axis
  std::optional<Vector3> scale;

  /// @brief Solid color to use for the whole model if `override_color` is true.
  std::optional<Color> color;

  /// @brief Whether to use the color specified in `color` instead of any materials embedded in the
  /// original model.
  bool override_color = false;

  /// @brief URL pointing to model file. One of `url` or `data` should be provided.
  std::string url;

  /// @brief [Media
  /// type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of embedded
  /// model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides
  /// the inferred media type if `url` is provided.
  std::string media_type;

  /// @brief Embedded model. One of `url` or `data` should be provided. If `data` is provided,
  /// `media_type` must be set to indicate the type of the data.
  std::vector<std::byte> data;
};

/// @brief A visual element in a 3D scene. An entity may be composed of multiple primitives which
/// all share the same frame of reference.
struct SceneEntity {
  /// @brief Timestamp of the entity
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference
  std::string frame_id;

  /// @brief Identifier for the entity. A entity will replace any prior entity on the same topic
  /// with the same `id`.
  std::string id;

  /// @brief Length of time (relative to `timestamp`) after which the entity should be automatically
  /// removed. Zero value indicates the entity should remain visible until it is replaced or
  /// deleted.
  std::optional<Duration> lifetime;

  /// @brief Whether the entity should keep its location in the fixed frame (false) or follow the
  /// frame specified in `frame_id` as it moves relative to the fixed frame (true)
  bool frame_locked = false;

  /// @brief Additional user-provided metadata associated with the entity. Keys must be unique.
  std::vector<KeyValuePair> metadata;

  /// @brief Arrow primitives
  std::vector<ArrowPrimitive> arrows;

  /// @brief Cube primitives
  std::vector<CubePrimitive> cubes;

  /// @brief Sphere primitives
  std::vector<SpherePrimitive> spheres;

  /// @brief Cylinder primitives
  std::vector<CylinderPrimitive> cylinders;

  /// @brief Line primitives
  std::vector<LinePrimitive> lines;

  /// @brief Triangle list primitives
  std::vector<TriangleListPrimitive> triangles;

  /// @brief Text primitives
  std::vector<TextPrimitive> texts;

  /// @brief Model primitives
  std::vector<ModelPrimitive> models;
};

/// @brief An update to the entities displayed in a 3D scene
struct SceneUpdate {
  /// @brief Scene entities to delete
  std::vector<SceneEntityDeletion> deletions;

  /// @brief Scene entities to add or replace
  std::vector<SceneEntity> entities;
};

/// @brief A collection of N-dimensional points, which may contain additional fields with
/// information like normals, intensity, etc.
struct PointCloud {
  /// @brief Timestamp of point cloud
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference
  std::string frame_id;

  /// @brief The origin of the point cloud relative to the frame of reference
  std::optional<Pose> pose;

  /// @brief Number of bytes between points in the `data`
  uint32_t point_stride = 0;

  /// @brief Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for
  /// each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each
  /// point's color.
  std::vector<PackedElementField> fields;

  /// @brief Point data, interpreted using `fields`
  std::vector<std::byte> data;
};

/// @brief A timestamped pose for an object or reference frame in 3D space
struct PoseInFrame {
  /// @brief Timestamp of pose
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference for pose position and orientation
  std::string frame_id;

  /// @brief Pose in 3D space
  std::optional<Pose> pose;
};

/// @brief An array of timestamped poses for an object or reference frame in 3D space
struct PosesInFrame {
  /// @brief Timestamp of pose
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference for pose position and orientation
  std::string frame_id;

  /// @brief Poses in 3D space
  std::vector<Pose> poses;
};

/// @brief A single block of an audio bitstream
struct RawAudio {
  /// @brief Timestamp of the start of the audio block
  std::optional<Timestamp> timestamp;

  /// @brief Audio data. The samples in the data must be interleaved and little-endian
  std::vector<std::byte> data;

  /// @brief Audio format. Only 'pcm-s16' is currently supported
  std::string format;

  /// @brief Sample rate in Hz
  uint32_t sample_rate = 0;

  /// @brief Number of channels in the audio block
  uint32_t number_of_channels = 0;
};

/// @brief A raw image
struct RawImage {
  /// @brief Timestamp of image
  std::optional<Timestamp> timestamp;

  /// @brief Frame of reference for the image. The origin of the frame is the optical center of the
  /// camera. +x points to the right in the image, +y points down, and +z points into the plane of
  /// the image.
  std::string frame_id;

  /// @brief Image width
  uint32_t width = 0;

  /// @brief Image height
  uint32_t height = 0;

  /// @brief Encoding of the raw image data
  /// @brief
  /// @brief Supported values: `8UC1`, `8UC3`, `16UC1` (little endian), `32FC1` (little endian),
  /// `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`,
  /// `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
  std::string encoding;

  /// @brief Byte length of a single row
  uint32_t step = 0;

  /// @brief Raw image data
  std::vector<std::byte> data;
};

/// @brief A channel for logging ArrowPrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the ArrowPrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class ArrowPrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<ArrowPrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The ArrowPrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const ArrowPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  ArrowPrimitiveChannel(const ArrowPrimitiveChannel& other) noexcept = delete;
  ArrowPrimitiveChannel& operator=(const ArrowPrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  ArrowPrimitiveChannel(ArrowPrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  ArrowPrimitiveChannel& operator=(ArrowPrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~ArrowPrimitiveChannel() = default;

private:
  explicit ArrowPrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging CameraCalibration messages to a topic.
///
/// @note While channels are fully thread-safe, the CameraCalibration struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class CameraCalibrationChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<CameraCalibrationChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The CameraCalibration message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const CameraCalibration& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  CameraCalibrationChannel(const CameraCalibrationChannel& other) noexcept = delete;
  CameraCalibrationChannel& operator=(const CameraCalibrationChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  CameraCalibrationChannel(CameraCalibrationChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  CameraCalibrationChannel& operator=(CameraCalibrationChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~CameraCalibrationChannel() = default;

private:
  explicit CameraCalibrationChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging CircleAnnotation messages to a topic.
///
/// @note While channels are fully thread-safe, the CircleAnnotation struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class CircleAnnotationChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<CircleAnnotationChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The CircleAnnotation message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const CircleAnnotation& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  CircleAnnotationChannel(const CircleAnnotationChannel& other) noexcept = delete;
  CircleAnnotationChannel& operator=(const CircleAnnotationChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  CircleAnnotationChannel(CircleAnnotationChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  CircleAnnotationChannel& operator=(CircleAnnotationChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~CircleAnnotationChannel() = default;

private:
  explicit CircleAnnotationChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Color messages to a topic.
///
/// @note While channels are fully thread-safe, the Color struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class ColorChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<ColorChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Color message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Color& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  ColorChannel(const ColorChannel& other) noexcept = delete;
  ColorChannel& operator=(const ColorChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  ColorChannel(ColorChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  ColorChannel& operator=(ColorChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~ColorChannel() = default;

private:
  explicit ColorChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging CompressedImage messages to a topic.
///
/// @note While channels are fully thread-safe, the CompressedImage struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class CompressedImageChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<CompressedImageChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The CompressedImage message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const CompressedImage& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  CompressedImageChannel(const CompressedImageChannel& other) noexcept = delete;
  CompressedImageChannel& operator=(const CompressedImageChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  CompressedImageChannel(CompressedImageChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  CompressedImageChannel& operator=(CompressedImageChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~CompressedImageChannel() = default;

private:
  explicit CompressedImageChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging CompressedVideo messages to a topic.
///
/// @note While channels are fully thread-safe, the CompressedVideo struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class CompressedVideoChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<CompressedVideoChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The CompressedVideo message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const CompressedVideo& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  CompressedVideoChannel(const CompressedVideoChannel& other) noexcept = delete;
  CompressedVideoChannel& operator=(const CompressedVideoChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  CompressedVideoChannel(CompressedVideoChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  CompressedVideoChannel& operator=(CompressedVideoChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~CompressedVideoChannel() = default;

private:
  explicit CompressedVideoChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging CylinderPrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the CylinderPrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class CylinderPrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<CylinderPrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The CylinderPrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const CylinderPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  CylinderPrimitiveChannel(const CylinderPrimitiveChannel& other) noexcept = delete;
  CylinderPrimitiveChannel& operator=(const CylinderPrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  CylinderPrimitiveChannel(CylinderPrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  CylinderPrimitiveChannel& operator=(CylinderPrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~CylinderPrimitiveChannel() = default;

private:
  explicit CylinderPrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging CubePrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the CubePrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class CubePrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<CubePrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The CubePrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const CubePrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  CubePrimitiveChannel(const CubePrimitiveChannel& other) noexcept = delete;
  CubePrimitiveChannel& operator=(const CubePrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  CubePrimitiveChannel(CubePrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  CubePrimitiveChannel& operator=(CubePrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~CubePrimitiveChannel() = default;

private:
  explicit CubePrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging FrameTransform messages to a topic.
///
/// @note While channels are fully thread-safe, the FrameTransform struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class FrameTransformChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<FrameTransformChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The FrameTransform message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const FrameTransform& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  FrameTransformChannel(const FrameTransformChannel& other) noexcept = delete;
  FrameTransformChannel& operator=(const FrameTransformChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  FrameTransformChannel(FrameTransformChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  FrameTransformChannel& operator=(FrameTransformChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~FrameTransformChannel() = default;

private:
  explicit FrameTransformChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging FrameTransforms messages to a topic.
///
/// @note While channels are fully thread-safe, the FrameTransforms struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class FrameTransformsChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<FrameTransformsChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The FrameTransforms message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const FrameTransforms& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  FrameTransformsChannel(const FrameTransformsChannel& other) noexcept = delete;
  FrameTransformsChannel& operator=(const FrameTransformsChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  FrameTransformsChannel(FrameTransformsChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  FrameTransformsChannel& operator=(FrameTransformsChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~FrameTransformsChannel() = default;

private:
  explicit FrameTransformsChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging GeoJSON messages to a topic.
///
/// @note While channels are fully thread-safe, the GeoJSON struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class GeoJSONChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<GeoJSONChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The GeoJSON message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const GeoJSON& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  GeoJSONChannel(const GeoJSONChannel& other) noexcept = delete;
  GeoJSONChannel& operator=(const GeoJSONChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  GeoJSONChannel(GeoJSONChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  GeoJSONChannel& operator=(GeoJSONChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~GeoJSONChannel() = default;

private:
  explicit GeoJSONChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Grid messages to a topic.
///
/// @note While channels are fully thread-safe, the Grid struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class GridChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<GridChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Grid message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Grid& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  GridChannel(const GridChannel& other) noexcept = delete;
  GridChannel& operator=(const GridChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  GridChannel(GridChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  GridChannel& operator=(GridChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~GridChannel() = default;

private:
  explicit GridChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging ImageAnnotations messages to a topic.
///
/// @note While channels are fully thread-safe, the ImageAnnotations struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class ImageAnnotationsChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<ImageAnnotationsChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The ImageAnnotations message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const ImageAnnotations& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  ImageAnnotationsChannel(const ImageAnnotationsChannel& other) noexcept = delete;
  ImageAnnotationsChannel& operator=(const ImageAnnotationsChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  ImageAnnotationsChannel(ImageAnnotationsChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  ImageAnnotationsChannel& operator=(ImageAnnotationsChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~ImageAnnotationsChannel() = default;

private:
  explicit ImageAnnotationsChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging KeyValuePair messages to a topic.
///
/// @note While channels are fully thread-safe, the KeyValuePair struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class KeyValuePairChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<KeyValuePairChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The KeyValuePair message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const KeyValuePair& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  KeyValuePairChannel(const KeyValuePairChannel& other) noexcept = delete;
  KeyValuePairChannel& operator=(const KeyValuePairChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  KeyValuePairChannel(KeyValuePairChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  KeyValuePairChannel& operator=(KeyValuePairChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~KeyValuePairChannel() = default;

private:
  explicit KeyValuePairChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging LaserScan messages to a topic.
///
/// @note While channels are fully thread-safe, the LaserScan struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class LaserScanChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<LaserScanChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The LaserScan message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const LaserScan& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  LaserScanChannel(const LaserScanChannel& other) noexcept = delete;
  LaserScanChannel& operator=(const LaserScanChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  LaserScanChannel(LaserScanChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  LaserScanChannel& operator=(LaserScanChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~LaserScanChannel() = default;

private:
  explicit LaserScanChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging LinePrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the LinePrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class LinePrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<LinePrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The LinePrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const LinePrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  LinePrimitiveChannel(const LinePrimitiveChannel& other) noexcept = delete;
  LinePrimitiveChannel& operator=(const LinePrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  LinePrimitiveChannel(LinePrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  LinePrimitiveChannel& operator=(LinePrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~LinePrimitiveChannel() = default;

private:
  explicit LinePrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging LocationFix messages to a topic.
///
/// @note While channels are fully thread-safe, the LocationFix struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class LocationFixChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<LocationFixChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The LocationFix message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const LocationFix& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  LocationFixChannel(const LocationFixChannel& other) noexcept = delete;
  LocationFixChannel& operator=(const LocationFixChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  LocationFixChannel(LocationFixChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  LocationFixChannel& operator=(LocationFixChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~LocationFixChannel() = default;

private:
  explicit LocationFixChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Log messages to a topic.
///
/// @note While channels are fully thread-safe, the Log struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class LogChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<LogChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Log message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Log& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  LogChannel(const LogChannel& other) noexcept = delete;
  LogChannel& operator=(const LogChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  LogChannel(LogChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  LogChannel& operator=(LogChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~LogChannel() = default;

private:
  explicit LogChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging SceneEntityDeletion messages to a topic.
///
/// @note While channels are fully thread-safe, the SceneEntityDeletion struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class SceneEntityDeletionChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<SceneEntityDeletionChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The SceneEntityDeletion message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const SceneEntityDeletion& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  SceneEntityDeletionChannel(const SceneEntityDeletionChannel& other) noexcept = delete;
  SceneEntityDeletionChannel& operator=(const SceneEntityDeletionChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  SceneEntityDeletionChannel(SceneEntityDeletionChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  SceneEntityDeletionChannel& operator=(SceneEntityDeletionChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~SceneEntityDeletionChannel() = default;

private:
  explicit SceneEntityDeletionChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging SceneEntity messages to a topic.
///
/// @note While channels are fully thread-safe, the SceneEntity struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class SceneEntityChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<SceneEntityChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The SceneEntity message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const SceneEntity& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  SceneEntityChannel(const SceneEntityChannel& other) noexcept = delete;
  SceneEntityChannel& operator=(const SceneEntityChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  SceneEntityChannel(SceneEntityChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  SceneEntityChannel& operator=(SceneEntityChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~SceneEntityChannel() = default;

private:
  explicit SceneEntityChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging SceneUpdate messages to a topic.
///
/// @note While channels are fully thread-safe, the SceneUpdate struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class SceneUpdateChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<SceneUpdateChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The SceneUpdate message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const SceneUpdate& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  SceneUpdateChannel(const SceneUpdateChannel& other) noexcept = delete;
  SceneUpdateChannel& operator=(const SceneUpdateChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  SceneUpdateChannel(SceneUpdateChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  SceneUpdateChannel& operator=(SceneUpdateChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~SceneUpdateChannel() = default;

private:
  explicit SceneUpdateChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging ModelPrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the ModelPrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class ModelPrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<ModelPrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The ModelPrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const ModelPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  ModelPrimitiveChannel(const ModelPrimitiveChannel& other) noexcept = delete;
  ModelPrimitiveChannel& operator=(const ModelPrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  ModelPrimitiveChannel(ModelPrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  ModelPrimitiveChannel& operator=(ModelPrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~ModelPrimitiveChannel() = default;

private:
  explicit ModelPrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging PackedElementField messages to a topic.
///
/// @note While channels are fully thread-safe, the PackedElementField struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class PackedElementFieldChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<PackedElementFieldChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The PackedElementField message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const PackedElementField& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  PackedElementFieldChannel(const PackedElementFieldChannel& other) noexcept = delete;
  PackedElementFieldChannel& operator=(const PackedElementFieldChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  PackedElementFieldChannel(PackedElementFieldChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  PackedElementFieldChannel& operator=(PackedElementFieldChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~PackedElementFieldChannel() = default;

private:
  explicit PackedElementFieldChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Point2 messages to a topic.
///
/// @note While channels are fully thread-safe, the Point2 struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class Point2Channel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<Point2Channel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Point2 message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Point2& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  Point2Channel(const Point2Channel& other) noexcept = delete;
  Point2Channel& operator=(const Point2Channel& other) noexcept = delete;
  /// @brief Default move constructor.
  Point2Channel(Point2Channel&& other) noexcept = default;
  /// @brief Default move assignment.
  Point2Channel& operator=(Point2Channel&& other) noexcept = default;
  /// @brief Default destructor.
  ~Point2Channel() = default;

private:
  explicit Point2Channel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Point3 messages to a topic.
///
/// @note While channels are fully thread-safe, the Point3 struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class Point3Channel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<Point3Channel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Point3 message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Point3& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  Point3Channel(const Point3Channel& other) noexcept = delete;
  Point3Channel& operator=(const Point3Channel& other) noexcept = delete;
  /// @brief Default move constructor.
  Point3Channel(Point3Channel&& other) noexcept = default;
  /// @brief Default move assignment.
  Point3Channel& operator=(Point3Channel&& other) noexcept = default;
  /// @brief Default destructor.
  ~Point3Channel() = default;

private:
  explicit Point3Channel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging PointCloud messages to a topic.
///
/// @note While channels are fully thread-safe, the PointCloud struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class PointCloudChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<PointCloudChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The PointCloud message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const PointCloud& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  PointCloudChannel(const PointCloudChannel& other) noexcept = delete;
  PointCloudChannel& operator=(const PointCloudChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  PointCloudChannel(PointCloudChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  PointCloudChannel& operator=(PointCloudChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~PointCloudChannel() = default;

private:
  explicit PointCloudChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging PointsAnnotation messages to a topic.
///
/// @note While channels are fully thread-safe, the PointsAnnotation struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class PointsAnnotationChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<PointsAnnotationChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The PointsAnnotation message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const PointsAnnotation& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  PointsAnnotationChannel(const PointsAnnotationChannel& other) noexcept = delete;
  PointsAnnotationChannel& operator=(const PointsAnnotationChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  PointsAnnotationChannel(PointsAnnotationChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  PointsAnnotationChannel& operator=(PointsAnnotationChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~PointsAnnotationChannel() = default;

private:
  explicit PointsAnnotationChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Pose messages to a topic.
///
/// @note While channels are fully thread-safe, the Pose struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class PoseChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<PoseChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Pose message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Pose& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  PoseChannel(const PoseChannel& other) noexcept = delete;
  PoseChannel& operator=(const PoseChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  PoseChannel(PoseChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  PoseChannel& operator=(PoseChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~PoseChannel() = default;

private:
  explicit PoseChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging PoseInFrame messages to a topic.
///
/// @note While channels are fully thread-safe, the PoseInFrame struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class PoseInFrameChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<PoseInFrameChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The PoseInFrame message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const PoseInFrame& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  PoseInFrameChannel(const PoseInFrameChannel& other) noexcept = delete;
  PoseInFrameChannel& operator=(const PoseInFrameChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  PoseInFrameChannel(PoseInFrameChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  PoseInFrameChannel& operator=(PoseInFrameChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~PoseInFrameChannel() = default;

private:
  explicit PoseInFrameChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging PosesInFrame messages to a topic.
///
/// @note While channels are fully thread-safe, the PosesInFrame struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class PosesInFrameChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<PosesInFrameChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The PosesInFrame message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const PosesInFrame& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  PosesInFrameChannel(const PosesInFrameChannel& other) noexcept = delete;
  PosesInFrameChannel& operator=(const PosesInFrameChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  PosesInFrameChannel(PosesInFrameChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  PosesInFrameChannel& operator=(PosesInFrameChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~PosesInFrameChannel() = default;

private:
  explicit PosesInFrameChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Quaternion messages to a topic.
///
/// @note While channels are fully thread-safe, the Quaternion struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class QuaternionChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<QuaternionChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Quaternion message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const Quaternion& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  QuaternionChannel(const QuaternionChannel& other) noexcept = delete;
  QuaternionChannel& operator=(const QuaternionChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  QuaternionChannel(QuaternionChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  QuaternionChannel& operator=(QuaternionChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~QuaternionChannel() = default;

private:
  explicit QuaternionChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging RawAudio messages to a topic.
///
/// @note While channels are fully thread-safe, the RawAudio struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class RawAudioChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<RawAudioChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The RawAudio message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const RawAudio& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  RawAudioChannel(const RawAudioChannel& other) noexcept = delete;
  RawAudioChannel& operator=(const RawAudioChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  RawAudioChannel(RawAudioChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  RawAudioChannel& operator=(RawAudioChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~RawAudioChannel() = default;

private:
  explicit RawAudioChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging RawImage messages to a topic.
///
/// @note While channels are fully thread-safe, the RawImage struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class RawImageChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<RawImageChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The RawImage message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const RawImage& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  RawImageChannel(const RawImageChannel& other) noexcept = delete;
  RawImageChannel& operator=(const RawImageChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  RawImageChannel(RawImageChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  RawImageChannel& operator=(RawImageChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~RawImageChannel() = default;

private:
  explicit RawImageChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging SpherePrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the SpherePrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class SpherePrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<SpherePrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The SpherePrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const SpherePrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  SpherePrimitiveChannel(const SpherePrimitiveChannel& other) noexcept = delete;
  SpherePrimitiveChannel& operator=(const SpherePrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  SpherePrimitiveChannel(SpherePrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  SpherePrimitiveChannel& operator=(SpherePrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~SpherePrimitiveChannel() = default;

private:
  explicit SpherePrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging TextAnnotation messages to a topic.
///
/// @note While channels are fully thread-safe, the TextAnnotation struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class TextAnnotationChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<TextAnnotationChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The TextAnnotation message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const TextAnnotation& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  TextAnnotationChannel(const TextAnnotationChannel& other) noexcept = delete;
  TextAnnotationChannel& operator=(const TextAnnotationChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  TextAnnotationChannel(TextAnnotationChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  TextAnnotationChannel& operator=(TextAnnotationChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~TextAnnotationChannel() = default;

private:
  explicit TextAnnotationChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging TextPrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the TextPrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class TextPrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<TextPrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The TextPrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const TextPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  TextPrimitiveChannel(const TextPrimitiveChannel& other) noexcept = delete;
  TextPrimitiveChannel& operator=(const TextPrimitiveChannel& other) noexcept = delete;
  /// @brief Default move constructor.
  TextPrimitiveChannel(TextPrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  TextPrimitiveChannel& operator=(TextPrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~TextPrimitiveChannel() = default;

private:
  explicit TextPrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging TriangleListPrimitive messages to a topic.
///
/// @note While channels are fully thread-safe, the TriangleListPrimitive struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class TriangleListPrimitiveChannel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<TriangleListPrimitiveChannel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The TriangleListPrimitive message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(
    const TriangleListPrimitive& msg, std::optional<uint64_t> log_time = std::nullopt
  ) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  TriangleListPrimitiveChannel(const TriangleListPrimitiveChannel& other) noexcept = delete;
  TriangleListPrimitiveChannel& operator=(const TriangleListPrimitiveChannel& other
  ) noexcept = delete;
  /// @brief Default move constructor.
  TriangleListPrimitiveChannel(TriangleListPrimitiveChannel&& other) noexcept = default;
  /// @brief Default move assignment.
  TriangleListPrimitiveChannel& operator=(TriangleListPrimitiveChannel&& other) noexcept = default;
  /// @brief Default destructor.
  ~TriangleListPrimitiveChannel() = default;

private:
  explicit TriangleListPrimitiveChannel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Vector2 messages to a topic.
///
/// @note While channels are fully thread-safe, the Vector2 struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class Vector2Channel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<Vector2Channel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Vector2 message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Vector2& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  Vector2Channel(const Vector2Channel& other) noexcept = delete;
  Vector2Channel& operator=(const Vector2Channel& other) noexcept = delete;
  /// @brief Default move constructor.
  Vector2Channel(Vector2Channel&& other) noexcept = default;
  /// @brief Default move assignment.
  Vector2Channel& operator=(Vector2Channel&& other) noexcept = default;
  /// @brief Default destructor.
  ~Vector2Channel() = default;

private:
  explicit Vector2Channel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

/// @brief A channel for logging Vector3 messages to a topic.
///
/// @note While channels are fully thread-safe, the Vector3 struct is not thread-safe.
/// Avoid modifying it concurrently or during a log operation.
class Vector3Channel {
public:
  /// @brief Create a new channel.
  ///
  /// @param topic The topic name. You should choose a unique topic name per channel for
  /// compatibility with the Foxglove app.
  /// @param context The context which associates logs to a sink. If omitted, the default context is
  /// used.
  static FoxgloveResult<Vector3Channel> create(
    const std::string_view& topic, const Context& context = Context()
  );

  /// @brief Log a message to the channel.
  ///
  /// @param msg The Vector3 message to log.
  /// @param log_time The timestamp of the message. If omitted, the current time is used.
  FoxgloveError log(const Vector3& msg, std::optional<uint64_t> log_time = std::nullopt) noexcept;

  /// @brief Uniquely identifies a channel in the context of this program.
  ///
  /// @return The ID of the channel.
  [[nodiscard]] uint64_t id() const noexcept;

  Vector3Channel(const Vector3Channel& other) noexcept = delete;
  Vector3Channel& operator=(const Vector3Channel& other) noexcept = delete;
  /// @brief Default move constructor.
  Vector3Channel(Vector3Channel&& other) noexcept = default;
  /// @brief Default move assignment.
  Vector3Channel& operator=(Vector3Channel&& other) noexcept = default;
  /// @brief Default destructor.
  ~Vector3Channel() = default;

private:
  explicit Vector3Channel(ChannelUniquePtr&& channel)
      : impl_(std::move(channel)) {}

  ChannelUniquePtr impl_;
};

}  // namespace foxglove::schemas
